<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zombies vs Humanos: Página principal</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zombies vs Humanos
   </div>
   <div id="projectbrief">Proposta de solução para o 2º projeto de LP1 2018/19</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Gerado por Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Localizar');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Localizar');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Zombies vs Humanos Documentação</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Zombies vs Humanos</h1>
<div class="image">
<img src="logo.png" alt=""/>
<div class="caption">
Zombies vs Humanos</div></div>
   <p>Proposta de resolução do <a href="https://github.com/VideojogosLusofona/lp1_2018_p2">2º Projeto de LP1 2018/19</a>.</p>
<h2>Sumário</h2>
<p>Este repositório contém uma proposta de resolução do <a href="https://github.com/VideojogosLusofona/lp1_2018_p2">2º Projeto de LP1 2018/19</a>, com os seguintes conteúdos:</p>
<ul>
<li>Código C# para implementação adequada da solução, considerando apenas a matéria lecionada em LP1 (uma vez que alguns aspetos poderiam ser melhorados com a matéria de LP2).</li>
<li>Documentação gerada em <a href="http://www.doxygen.nl/index.html">Doxygen</a>, disponível <a href="https://videojogoslusofona.github.io/lp1_2018_p2_solucao/">aqui</a>.</li>
<li>Sugestão de bom uso de Git e <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/commits/master">boas mensagens de <em>commit</em></a>.</li>
<li>Exemplo de como elaborar algumas partes do relatório, nomeadamente:<ul>
<li>Como escrever a <em>Arquitetura da solução</em> e <em>Referências</em>.</li>
<li>Como fazer um diagrama UML de classes.</li>
<li>Como fazer um fluxograma.</li>
</ul>
</li>
</ul>
<h2>Arquitetura da solução</h2>
<h3>Funcionamento do programa</h3>
<p>O programa deve ser invocado com as opções da linha de comandos indicadas no <a href="https://github.com/VideojogosLusofona/lp1_2018_p2#invoca%C3%A7%C3%A3o-do-programa">enunciado</a>, seguindo depois a sequência indicada no fluxograma apresentado na Figura 1.</p>
<div class="image">
<img src="fluxograma.png" alt=""/>
<div class="caption">
Fluxograma</div></div>
   <p><b>Figura 1</b> - Fluxograma do programa (código fonte da figura disponível <a href="imgsource/fluxograma.drawio">aqui</a>, tendo a mesma sido gerada em <a href="https://www.draw.io/">Draw.io</a>).</p>
<p>O programa começa por tratar as opções da linha de comandos, e se as mesmas forem válidas é criado o mundo de simulação, bem como os agentes que o compõem, caso contrário, o programa termina. Após a primeira renderização, entramos no <em>game loop</em>, no qual cada iteração do ciclo corresponde a um turno do jogo. Em cada turno, cada agente realiza a sua ação (mover ou infetar), e caso exista uma alteração na população, é feita uma recontagem dos agentes. A visualização é sempre atualizada após a ação de cada agente. O <em>game loop</em> termina quando não existirem mais humanos ou quando tiver sido atingido o número máximo de turnos. O programa termina com uma mensagem indicando o resultado final do jogo.</p>
<p>A nível do código, o programa tem início no método <code>Main()</code>, que se encontra na classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Program.cs"><code>Program</code></a>. O <code>Main()</code> começa por criar uma instância de [<code>ConsoleUserInterface</code>] (que representa a interface de utilizador), disponibilizando-a globalmente numa propriedade estática chamada <code>UI</code> (em LP2 discutiremos o <a href="https://dotnettutorials.net/lesson/singleton-design-pattern/"><em>Singleton design pattern</em></a>, que é geralmente mais apropriado para disponibilizar uma única instância globalmente). De seguida é invocado o método <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs#L175"><code>Options.ParseArgs()</code></a>, que trata as opções da linha de comandos e devolve uma instância de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a> que disponibiliza as opções já tratadas e validadas sob a forma de propriedades. Se ocorrer um erro no tratamento das opções o programa termina por aqui, caso contrário é criada uma nova instância da classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Game.cs"><code>Game</code></a> e invocado o método <code>Play()</code> nessa mesma instância, dando início ao jogo.</p>
<p>As relações entre <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Program.cs"><code>Program</code></a> e as instâncias de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/ConsoleUserInterface.cs"><code>ConsoleUserInterface</code></a>, <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a> e <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Game.cs"><code>Game</code></a> são mostradas no diagrama UML apresentado na Figura 2. Como é possível observar nesta figura, a instância de UI é representada pela interface <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/IUserInterface.cs"><code>IUserInterface</code></a>, o que permite usar UIs alternativas, como por exemplo uma UI gráfica (GUI). As restantes classes, nomeadamente a classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Game.cs"><code>Game</code></a>, nunca têm conhecimento que se trata na realidade de uma instância de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/ConsoleUserInterface.cs"><code>ConsoleUserInterface</code></a>.</p>
<div class="image">
<img src="UML.png" alt=""/>
<div class="caption">
Diagrama UML de classes</div></div>
   <p><b>Figura 2</b> - Diagrama UML de classes da solução (código fonte da figura disponível <a href="imgsource/uml.yuml">aqui</a>, tendo a mesma sido gerada em <a href="https://yuml.me/">yUML</a>). Para simplificação do diagrama são apenas mostradas as relações de dependência mais importantes.</p>
<h3>Design de classes</h3>
<h4>Responsabilidades e relações entre as principais classes e tipos</h4>
<p>A classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Game.cs"><code>Game</code></a> é uma das mais importantes neste projeto. É durante a sua instanciação que é criado o mundo de simulação (instância de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/IReadOnlyWorld.cs"><code>IReadOnlyWorld</code></a>), bem como dos agentes que o compõem. Esta classe é também responsável pelo <em>game loop</em>, implementado no método <code>Play()</code>.</p>
<p>Como é possível observar na Figura 2, a classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Agent.cs"><code>Agent</code></a> é central neste projeto. A classe tem várias propriedades públicas que a definem, nomeadamente: a) propriedade <code>Kind</code>, do tipo <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AgentKind.cs"><code>AgentKind</code></a>, enumeração que define se o agente é zombie ou humano; b) propriedade <code>Movement</code>, do tipo <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AgentMovement.cs"><code>AgentMovement</code></a>, enumeração que indica se o agente é controlado pela IA ou pelo jogador; e, c) propriedade <code>Pos</code>, do tipo <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Coord.cs"><code>Coord</code></a>, <em>struct</em> que define a posição do agente no mundo de simulação. A classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Agent.cs"><code>Agent</code></a> possui também a variável de instância privada <code>moveBehavior</code>, do tipo <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AbstractMovement.cs"><code>AbstractMovement</code></a>, responsável por realizar o movimento do agente. Sendo <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AbstractMovement.cs"><code>AbstractMovement</code></a> um tipo abstrato, o movimento será realizado: a) pelo jogador, se a variável for do tipo concreto <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/PlayerMovement.cs"><code>PlayerMovement</code></a>; ou, b) pela IA, se a variável for do tipo concreto <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AIMovement.cs"><code>AIMovement</code></a>. Naturalmente, tanto <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/PlayerMovement.cs"><code>PlayerMovement</code></a> como <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AIMovement.cs"><code>AIMovement</code></a> estendem <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AbstractMovement.cs"><code>AbstractMovement</code></a>, relação de herança bem visível na Figura 2. O agente, ao invocar o método <code>WhereToMove()</code> da classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AbstractMovement.cs"><code>AbstractMovement</code></a> não sabe se o movimento vai ser feito pelo jogador ou pela IA, pois isso depende do tipo concreto guardado na variável <code>moveBehavior</code>. É uma situação clara de <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/polymorphism">polimorfismo</a>. É de realçar ainda que as instâncias de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AIMovement.cs"><code>AIMovement</code></a> possuem uma referência ao género do agente inimigo (enumeração <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AgentKind.cs"><code>AgentKind</code></a>), uma vez que, para tomar uma decisão, precisam de saber quem são os agentes inimigos.</p>
<p>A classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/World.cs"><code>World</code></a> representa o mundo de simulação, contendo uma referência a cada um dos agentes existentes no mesmo. Por sua vez, os agentes, bem como as classes <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Game.cs"><code>Game</code></a> e <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AbstractMovement.cs"><code>AbstractMovement</code></a>, também contêm uma referência ao mundo de simulação. No entanto estas duas últimas fazem-no indiretamente através da interface <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/IReadOnlyWorld.cs"><code>IReadOnlyWorld</code></a>, que a classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/World.cs"><code>World</code></a> implementa. Como o nome indica, a interface <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/IReadOnlyWorld.cs"><code>IReadOnlyWorld</code></a> apenas define funcionalidade para leitura do mundo (por exemplo, para saber o que existe em dada célula do mundo), não permitindo alteração dos conteúdos do mesmo. Uma vez que tanto <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Game.cs"><code>Game</code></a> como <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AbstractMovement.cs"><code>AbstractMovement</code></a> não precisam de alterar o mundo, o mesmo fica protegido de alterações indevidas quando visto como um <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/IReadOnlyWorld.cs"><code>IReadOnlyWorld</code></a>. A classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Agent.cs"><code>Agent</code></a> é a única que pode alterar o mundo, e dessa forma possui uma referência direta ao mesmo.</p>
<h4>Classes vs <em>structs</em> vs enumerações</h4>
<p>A maioria dos tipos criados neste projeto são classes, com a exceção das <em>structs</em> <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Coord.cs"><code>Coord</code></a> e <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a>. No caso da primeira, uma vez que se trata de um tipo muito simples e imutável (serve apenas para guardar uma coordenada <em>x</em>, <em>y</em>), optou-se por tornar este tipo uma <em>struct</em>.</p>
<p>O caso de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a> não é tão claro. Trata-se essencialmente de um tipo que serve como contentor de opções validadas, imutável após a sua instanciação, e nesse sentido encaixa bem como uma <em>struct</em>. No entanto contém 11 campos, o que torna mais pesada a sua cópia por valor. Uma vez que isto acontece numa única ocasião – quando a instância de <code>Options</code> é passada ao construtor de <code>Game</code> – optou-se por manter o tipo <code>Options</code> como uma <em>struct</em>. Seria perfeitamente válido ter usado uma classe neste caso.</p>
<p>Os tipos <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AgentKind.cs"><code>AgentKind</code></a>, <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AgentMovement.cs"><code>AgentMovement</code></a> e <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Direction.cs"><code>Direction</code></a> são naturalmente enumerações pois representam um número limitado de valores possíveis, por exemplo <em>Zombie</em> ou <em>Humano</em> no caso de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AgentKind.cs"><code>AgentKind</code></a>.</p>
<h3>Estruturas de dados e algoritmos utilizados</h3>
<h4>Onde estão os agentes?</h4>
<p>Os agentes, representados por instâncias da classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Agent.cs"><code>Agent</code></a>, encontram-se referenciados em duas estruturas de dados distintas:</p>
<ol type="1">
<li>Num <em>array</em> na classe [<code>Game</code>] (variável de instância <code>agents</code>).</li>
<li>Num <em>array</em> bidimensional na classe [<code>World</code>] (variável de instância <code>world</code>).</li>
</ol>
<p>No primeiro caso, uma vez que o número total de agentes nunca muda ao longo do jogo, podemos usar um simples <em>array</em> de tamanho fixo, em vez de uma lista por exemplo, obedecendo assim ao princípio <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS</a>. É necessário que a classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Game.cs"><code>Game</code></a> contenha as referência dos agentes por duas razões: i) para podermos embaralhá-los antes de cada turno (para este efeito usamos o algoritmo de <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher–Yates</a>, implementado no método <code>Shuffle()</code>); e, ii) para podermos contar o número de cada género de agentes existentes no jogo (ação que é realizada no método <code>ReCountAgents()</code> usando parâmetros <code>out</code>).</p>
<p>No segundo caso, simplifica bastante o projeto se a classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/World.cs"><code>World</code></a> conseguir rapidamente determinar se existem ou não agentes, bem como o seu género, em cada posição do mundo de simulação. Para este efeito usa-se um <em>array</em> bidimensional de agentes, do tamanho do mundo. Cada posição deste <em>array</em> ou tem uma referência a um agente ou tem o valor <code>null</code>, sendo este último uma indicação de que a posição não contém nenhum agente.</p>
<h4>Mundo toroidal com vizinhança de Moore</h4>
<p>O mundo de simulação tem a particularidade de ser toroidal ("dá a volta") e ter uma vizinhança de Moore. Uma vez que estas são características do mundo, faz sentido que as mesmas estejam programadas na classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/World.cs"><code>World</code></a>. Métodos desta classe que lidam com coordenadas antes de mais tratam essas coordenadas com o método privado <code>Normalize()</code>. Se as coordenadas forem válidas, o método <code>Normalize()</code> não faz nada; por outro lado, se as coordenadas não corresponderem a uma posição no mundo (por exemplo, se já deviam ter "dado
a volta"), o método <code>Normalize()</code> retifica as mesmas, fazendo-as "dar a volta" corretamente. Desta forma, todos os métodos da classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/World.cs"><code>World</code></a> garantem que estão a lidar com coordenadas válidas num mundo toroidal.</p>
<p>O método <code>VectorBetween()</code> aceita duas coordenadas, normaliza-as, e devolve um vetor que parte da primeira coordenada e termina na segunda, garantido que esse vetor representa o caminho mais curto entre essas duas coordenadas num mundo toroidal.</p>
<p>Os dois <em>overloads</em> do método <code>GetNeighbor()</code> devolvem a coordenada do vizinho de uma dada célula, aceitando ou uma direção (enumeração <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Direction.cs"><code>Direction</code></a>) ou um vetor (<em>struct</em> <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Coord.cs"><code>Coord</code></a>) que indica em que lado está o vizinho.</p>
<p>Estes métodos simplificam bastante o restante código do projeto, que pode perfeitamente ignorar os detalhes de como implementar um mundo toroidal com vizinhança de Moore, uma vez que tais detalhes estão encapsulados na classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/World.cs"><code>World</code></a>.</p>
<h4>Movimento automático dos agentes</h4>
<p>O movimento automático dos agentes está implementado no método <code>WhereToMove()</code> da classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/AIMovement.cs"><code>AIMovement</code></a>. Basicamente trata-se de um triplo ciclo <code>for</code>, em que o ciclo externo percorre os raios de 1 até ao raio máximo (igual a metade da maior dimensão do mundo, <em>x</em> ou <em>y</em>). Em cada iteração do ciclo externo o valor do raio é dado na variável <code>r</code>. O ciclo <code>for</code> intermédio percorre, de <code>-r</code> a <code>r</code>, a distância vertical <code>dy</code> entre o agente que se quer mover e as possíveis células destino. Por sua vez, o ciclo <code>for</code> interno percorre também essa distância, mas na horizontal (<code>dx</code>).</p>
<p>Dentro do ciclo interno, tendo a coordenada do agente, bem como as distâncias vertical e horizontal até à possível célula destino, obtemos a coordenada <code>x</code>, <code>y</code> da mesma da seguinte forma (pseudo-código):</p>
<ul>
<li><code>x = agent.X + dx</code></li>
<li><code>y = agent.Y + dy</code></li>
</ul>
<p>Uma vez obtida essa coordenada, verificamos se a respetiva célula contém um agente e se esse agente é um inimigo do agente que se quer mover. Em caso afirmativo obtemos um vetor (ver secção anterior) entre a posição do agente que se quer mover e a posição do inimigo, colocando a variável <code>foundEnemy</code> a <code>true</code>, provocando o fim do triplo <code>for</code>. Caso contrário, continua a procura por um agente inimigo.</p>
<p>Uma vez terminado o triplo ciclo <code>for</code>, e caso tenha sido encontrado um inimigo, o método <code>WhereToMove()</code> devolve a posição vizinha na direção desse inimigo, usando para tal o método <code>GetNeighbor()</code> da classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/World.cs"><code>World</code></a>, tal como descrito na secção anterior. Caso contrário devolve a posição do agente que se quer mover, o que resulta num não-movimento por parte desse agente.</p>
<h4>Fila de mensagens para o utilizador</h4>
<p>A interface <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/IUserInterface.cs"><code>IUserInterface</code></a> define o método <code>RenderMessage()</code>, pelo que as classes que a implementam são obrigadas a ter este método. Segundo a documentação da interface, este método "*apresenta uma mensagem ao utilizador*", no entanto a forma como tal é feito fica a cargo das classes concretas que implementam a interface. Neste caso, a classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/ConsoleUserInterface.cs"><code>ConsoleUserInterface</code></a> é a única fazê-lo. A forma como esta classe lida com as mensagens é a seguinte. Em particular, quando o método <code>RenderMessage()</code> recebe uma mensagem, são realizadas as seguintes ações:</p>
<ul>
<li>A mensagem é tratada de modo a ter um tamanho fixo, adicionando espaços no fim ou removendo carateres a mais, conforme o caso.</li>
<li>A mensagem tratada é colocada numa fila (variável de instância do tipo <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1"><code>Queue&lt;string&gt;</code></a>). A fila tem um tamanho máximo, e se o número de mensagens exceder esse máximo, a mensagem mais antiga é descartada.</li>
<li>É construída uma <em>string</em> contendo todas as mensagens, exceto a última (cada mensagem separada por uma nova linha, <code>\n</code>).</li>
<li>O cursor é posicionado no local onde é suposto serem impressas as mensagens, e a <em>string</em> contendo as mensagens (exceto a última) é impressa de uma só vez, num único <code>Console.Write()</code>, com cores específicas de fundo e primeiro plano.</li>
<li>É impressa a última mensagem, com uma cor diferente de fundo e primeiro plano, diferenciando-se assim das restantes mensagens.</li>
</ul>
<p>Isto provoca um efeito de <em>scrolling</em>, semelhante aos <em>logs</em> de vários jogos. É de realçar que outra classe que implemente <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/IUserInterface.cs"><code>IUserInterface</code></a> pode ter a sua própria forma específica de mostrar as mensagens ao utilizador.</p>
<h4>Visualização do mundo de simulação usando uma <em>cache</em></h4>
<p>A renderização do mundo é realizada pelo método <code>RenderWorld()</code> da classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/ConsoleUserInterface.cs"><code>ConsoleUserInterface</code></a>, também definido na interface <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/IUserInterface.cs"><code>IUserInterface</code></a>. No entanto a impressão de carateres na consola, com diferentes cores, pode ser um pouco lenta. Para minimizar essa situação, entre cada nova renderização podemos reimprimir apenas as posições em que ocorreram alterações, deixando o resto da visualização tal como está.</p>
<p>Existem várias formas de alcançar este objetivo. Neste projeto optou-se por usar uma <em>cache</em> de visualização que contém o estado anterior do mundo. Embora o termo <em>cache</em> esteja mais relacionado com pequenas memórias RAM muito rápidas, tipicamente associadas ao microprocessador, de um modo mais geral podemos considerar uma <em>cache</em> como qualquer memória intermédia que sirva o propósito de acelerar uma computação.</p>
<p>Neste caso a <em>cache</em> de visualização é uma variável de instância da classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/ConsoleUserInterface.cs"><code>ConsoleUserInterface</code></a>, do tipo <em>array</em> bidimensional de <em>strings</em>, com dimensão igual à do mundo de simulação. Quando o mundo é desenhado no ecrã pela primeira vez no ecrã, é guardada em cada posição da <em>cache</em> uma <em>string</em> representativa do conteúdo de cada célula do mundo. Nas renderizações seguintes, o conteúdo de cada célula do mundo é comparado com a respetiva <em>string</em> na <em>cache</em>. Se o conteúdo não tiver sido alterado, nada é desenhado, ficando no ecrã o que já lá estava antes. Se o conteúdo for diferente, então a respetiva célula é redesenhada. Desta forma a visualização fica bastante mais fluida.</p>
<h4>Tratamento de opções na linha de comandos</h4>
<p>Como já referido, o tratamento de opções da linha comando é da responsabilidade da classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a>. O método <code>Main()</code> invoca o método estático <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs#L175"><code>Options.ParseArgs()</code></a>, que recebe como argumentos as opções da linha de comandos, devolvendo uma instância de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a> que disponibiliza as opções tratadas e validadas sob a forma de propriedades.</p>
<p>O método <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs#L175"><code>Options.ParseArgs()</code></a> verifica se o número de argumentos, é o correto, entrando num ciclo que processa os argumentos aos pares, de modo a analisar cada par <em>opção-valor</em> de uma só vez (por exemplo, <code>-z 10</code>). Em cada iteração, o ciclo faz o seguinte:</p>
<ol type="1">
<li>Confirma se a opção é válida, verificando se a mesma existe numa lista de opções válidas disponível na variável de classe <code>validOptions</code>. Senão existir, é criada uma instância de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a> com indicação desse erro, terminando o ciclo.</li>
<li>Confirma se a opção é repetida. As opções e os seus valores vão sendo guardadas num dicionário (variável local <code>options</code>). Caso o dicionário já contenha a opção em tratamento, é criada uma instância de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a> com indicação desse erro, terminando o ciclo.</li>
<li>Verifica se o valor da opção é um número inteiro não negativo. Senão for, é criada uma instância de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a> com indicação desse erro, terminando o ciclo.</li>
<li>Guarda a opção e o seu valor no dicionário, voltando ao início.</li>
</ol>
<p>Após o fim do ciclo, e caso não exista uma instância de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a> com indicação de erro, é criada uma nova instância de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a> com as opções e valores guardados no dicionário, sendo depois invocado o método <code>Validate()</code> nesta mesma instância. Este método verifica se as opções são válidas ou fazem sentido, não permitindo por exemplo que o tamanho do mundo seja zero, que existam mais agentes controlados por jogadores do que o total de agentes, ou até que o número total de agentes exceda a capacidade do mundo. Se algum destes erros ocorrer, essa mesma indicação é gravada na instância de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a>.</p>
<p>O método termina devolvendo a instância de <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/Options.cs"><code>Options</code></a> criada. Se a mesma tiver indicação de algum erro, o programa termina, indicando o erro ou os erros em questão.</p>
<h3>Personalização da visualização e andamento do jogo</h3>
<p>As dimensões, cores e posicionamentos dos diferentes componentes do mundo de jogo podem ser facilmente personalizados modificando as variáveis de instância presentes entre as linhas <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/ConsoleUserInterface.cs#L37">37</a> e <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/ConsoleUserInterface.cs#L248">248</a> da classe <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/ConsoleUserInterface.cs"><code>ConsoleUserInterface</code></a>. Idealmente os valores destas variáveis deveriam ser lidos de um ficheiro de texto, de modo a permitir a personalização do jogo sem necessidade de recompilar o mesmo. Contudo, e apesar de tal abordagem ser valorizada, não seria de todo necessária num projeto deste tipo.</p>
<p>Entre as linhas <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/ConsoleUserInterface.cs#L248">250</a> e <a href="https://github.com/VideojogosLusofona/lp1_2018_p2_solucao/blob/master/ZombiesVsHumans/ConsoleUserInterface.cs#L310">310</a> da mesma classe existem algumas variáveis de instância adicionais relacionadas com a dimensão e posicionamento dos elementos do mundo. No entanto estas não devem ser modificadas, pois o seu valor é calculado automaticamente a partir das anteriores no método <code>Initialize()</code>.</p>
<h2>Referências</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher–Yates shuffle - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/KISS_principle">KISS principle - Wikipedia</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/polymorphism">Polymorphism (C# Programming Guide) - Microsoft Docs</a></li>
<li><a href="https://dotnettutorials.net/lesson/singleton-design-pattern/">Singleton Design Pattern in C# - Dot Net Tutorials</a></li>
<li><a href="https://exceptionnotfound.net/strategy-the-daily-design-pattern/">The Strategy Design Pattern in C# - Exception Not Found</a></li>
<li><a href="https://en.wikipedia.org/wiki/Moore_neighborhood">Moore neighborhood - Wikipedia</a></li>
<li><a href="https://stackoverflow.com/questions/521298/when-to-use-struct">When to use struct? - StackOverflow</a></li>
</ul>
<h2>Metadados</h2>
<ul>
<li>Autor: <a href="https://github.com/fakenmc">Nuno Fachada</a></li>
<li>Curso: <a href="https://www.ulusofona.pt/licenciatura/videojogos">Licenciatura em Videojogos</a></li>
<li>Instituição: <a href="https://www.ulusofona.pt/">Universidade Lusófona de Humanidades e Tecnologias</a></li>
</ul>
<h2>Licenças e atribuições</h2>
<ul>
<li>O código é disponibilizado através da licença <a href="http://www.gnu.org/licenses/gpl.html">GPLv3</a>.</li>
<li>A documentação é disponibilizada através da licença <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>.</li>
<li>O <a href="logo.png">logótipo</a> do projeto é baseado nos ícones desenhados por <a href="https://www.freepik.com/home">Freepik</a> disponíveis em <a href="https://www.flaticon.com">https://www.flaticon.com</a>. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Gerado por
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
